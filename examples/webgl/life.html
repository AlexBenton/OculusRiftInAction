<html>
<head>
<title>Conway's Game of Life on GPU</title>

<script id="shader-vs" type="x-shader/x-vertex"> 
  attribute vec3 aPos;
  attribute vec2 aTexCoord;
  varying   vec2 vTexCoord;
void main(void) {
   gl_Position = vec4(aPos, 1.);
   vTexCoord = aTexCoord;
}
</script> 

<script id="shader-fs" type="x-shader/x-fragment"> 
precision mediump float;
  uniform sampler2D uTexSamp;
  varying vec2 vTexCoord;
  const float d = 1./512.;
void main(void) {
   float c = texture2D(uTexSamp, vTexCoord).x;
   int s = 0;
   if (texture2D(uTexSamp, vTexCoord + vec2(0., d)).x > 0.) s++;
   if (texture2D(uTexSamp, vTexCoord - vec2(0., d)).x > 0.) s++;
   if (texture2D(uTexSamp, vTexCoord + vec2(d, 0.)).x > 0.) s++;
   if (texture2D(uTexSamp, vTexCoord - vec2(d, 0.)).x > 0.) s++;
   if (texture2D(uTexSamp, vTexCoord + vec2(d, d)).x > 0.) s++;
   if (texture2D(uTexSamp, vTexCoord - vec2(d, d)).x > 0.) s++;
   if (texture2D(uTexSamp, vTexCoord + vec2(d, -d)).x > 0.) s++;
   if (texture2D(uTexSamp, vTexCoord - vec2(d, -d)).x > 0.) s++;
   if (c > 0.){
     if ((s == 2) || (s == 3)) gl_FragColor = vec4(1.);
     else gl_FragColor = vec4(vec3(0.),1.);}
   else if (s == 3) gl_FragColor = vec4(1.);
        else gl_FragColor = vec4(vec3(0.),1.);
}
</script> 
 
<script id="shader-fs-show" type="x-shader/x-fragment"> 
precision mediump float;
  uniform sampler2D uTexSamp;
  varying vec2 vTexCoord;
void main(void) {
   gl_FragColor = texture2D(uTexSamp, vTexCoord);
}
</script> 

<script id="shader-vs-distort" type="x-shader/x-vertex">
uniform vec2 EyeToSourceUVScale;
uniform vec2 EyeToSourceUVOffset;
attribute vec2 Position;
attribute vec4 Color;
attribute vec2 TexCoord0;
varying vec4 oColor;
varying vec2 oTexCoord0;
void main()
{
   gl_Position.x = Position.x;
   gl_Position.y = Position.y;
   gl_Position.z = 0.5;
   gl_Position.w = 1.0;
   oTexCoord0 = TexCoord0 * EyeToSourceUVScale + EyeToSourceUVOffset;
   oTexCoord0.y = 1.0 - oTexCoord0.y;
   oColor = Color;
}
</script> 

<script id="shader-fs-distort" type="x-shader/x-fragment"> 
precision mediump float;

uniform sampler2D Texture0;

varying vec4 oColor;
varying vec2 oTexCoord0;

void main()
{
   gl_FragColor = texture2D(Texture0, oTexCoord0);
   gl_FragColor.a = 1.0;
}
</script> 

<script type="text/javascript" src="mesh.json">
</script>

<script type="text/javascript">
function getShader ( gl, id ){
   var shaderScript = document.getElementById ( id );
   var str = "";
   var k = shaderScript.firstChild;
   while ( k ){
     if ( k.nodeType == 3 ) str += k.textContent;
     k = k.nextSibling;
   }
   var shader;
   if ( shaderScript.type == "x-shader/x-fragment" ) {
     shader = gl.createShader ( gl.FRAGMENT_SHADER );
   } else if ( shaderScript.type == "x-shader/x-vertex" ) {
     shader = gl.createShader(gl.VERTEX_SHADER);
   }
   else return null;
   gl.shaderSource(shader, str);
   gl.compileShader(shader);
   
   var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
   if (!compiled) {
     var compilationLog = gl.getShaderInfoLog(shader);
     console.log('Shader compiler log: ' + compilationLog);
   }
   return shader;
}

var gl, prog, prog_show, prog_distort; 
var FBO, FBO2, texture, texture2, animation;
var delay = 10, density = .24, it = 1, frames = 0, time, timer;

function main() {
   clearInterval(timer);
   var c = document.getElementById("c");
   try { gl = c.getContext("experimental-webgl", {depth : false } );
   } catch(e) {}
   if ( !gl ) {alert("Your browser does not support WebGL"); return;}

   vaoExt = gl.getExtension('OES_vertex_array_object');

   prog  = gl.createProgram();
   gl.attachShader(prog, getShader( gl, "shader-vs" ));
   gl.attachShader(prog, getShader( gl, "shader-fs" ));
   gl.linkProgram(prog);
   computeVao = vaoExt.createVertexArrayOES();

   vaoExt.bindVertexArrayOES(computeVao);
   var posBuffer = gl.createBuffer();
   gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
   var vertices = new Float32Array([-1,-1,0, 1,-1,0, -1,1,0, 1,1,0]);
   var aPosLoc = gl.getAttribLocation(prog, "aPos");
   gl.enableVertexAttribArray( aPosLoc );
   var aTexLoc = gl.getAttribLocation(prog, "aTexCoord");
   gl.enableVertexAttribArray( aTexLoc );
   var texCoords = new Float32Array([0,0, 1,0, 0,1, 1,1]);
   var texCoordOffset = vertices.byteLength;
   gl.bufferData(gl.ARRAY_BUFFER,
       texCoordOffset + texCoords.byteLength, gl.STATIC_DRAW);
   gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertices);
   gl.bufferSubData(gl.ARRAY_BUFFER, texCoordOffset, texCoords);
   gl.vertexAttribPointer(aPosLoc, 3, gl.FLOAT, gl.FALSE, 0, 0);
   gl.vertexAttribPointer(aTexLoc, 2, gl.FLOAT, gl.FALSE, 0, texCoordOffset);
   vaoExt.bindVertexArrayOES(null);

   prog_show  = gl.createProgram();
   gl.attachShader(prog_show, getShader( gl, "shader-vs" ));
   gl.attachShader(prog_show, getShader( gl, "shader-fs-show" ));
   gl.linkProgram(prog_show);

   prog_distort  = gl.createProgram();
   gl.attachShader(prog_distort, getShader( gl, "shader-vs-distort" ));
   gl.attachShader(prog_distort, getShader( gl, "shader-fs-distort" ));
   gl.linkProgram(prog_distort);
   gl.useProgram(prog_distort);

   var scaleLoc = gl.getUniformLocation(prog_distort, "EyeToSourceUVScale");
   gl.uniform2f(scaleLoc, mesh.left.scale[0], mesh.left.scale[1]);
   var scaleLoc = gl.getUniformLocation(prog_distort, "EyeToSourceUVOffset");
   gl.uniform2f(scaleLoc, mesh.left.offset[0], mesh.left.offset[1]);

   var distortVertices = new Float32Array(mesh.left.mesh.vertices);
   var distortIndices = new Int16Array(mesh.left.mesh.indices);
   distortVao = vaoExt.createVertexArrayOES();
   vaoExt.bindVertexArrayOES(distortVao);

   var distortIndexBuffer = gl.createBuffer();
   gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, distortIndexBuffer);
   gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, distortIndices, gl.STATIC_DRAW);

   var distortVertexBuffer = gl.createBuffer();
   gl.bindBuffer(gl.ARRAY_BUFFER, distortVertexBuffer);
   gl.bufferData(gl.ARRAY_BUFFER, distortVertices, gl.STATIC_DRAW);
   
   var PosLoc = gl.getAttribLocation(prog_distort, "Position");
   gl.enableVertexAttribArray( PosLoc );
   gl.vertexAttribPointer(PosLoc, 2, gl.FLOAT, gl.FALSE, 40, 0);
   var TexLoc = gl.getAttribLocation(prog_distort, "TexCoord0");
   gl.enableVertexAttribArray( TexLoc );
   gl.vertexAttribPointer(TexLoc, 2, gl.FLOAT, gl.FALSE, 40, 24);
   vaoExt.bindVertexArrayOES(null);

   texture = gl.createTexture();
   gl.bindTexture(gl.TEXTURE_2D, texture);
   gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
   var pixels = [], tSize = 512;
   for(var i = 0; i<tSize; i++)
     for(var j = 0; j<tSize; j++)
       if(Math.random() > density) pixels.push( 0, 0,0,0 );
       else pixels.push( 255, 0,0,0 );
   gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, tSize, tSize, 0, gl.RGBA,
       gl.UNSIGNED_BYTE, new Uint8Array(pixels));
   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
   texture2 = gl.createTexture();

   gl.bindTexture(gl.TEXTURE_2D, texture2);
   gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
   gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, tSize, tSize, 0, gl.RGBA,
       gl.UNSIGNED_BYTE, new Uint8Array(pixels));
   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
//   gl.uniform1i(gl.getUniformLocation(prog, "uTexSamp"), 0);
   FBO = gl.createFramebuffer();
   gl.bindFramebuffer(gl.FRAMEBUFFER, FBO);
   gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
       gl.TEXTURE_2D, texture, 0);
   FBO2 = gl.createFramebuffer();
   gl.bindFramebuffer(gl.FRAMEBUFFER, FBO2);
   gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
       gl.TEXTURE_2D, texture2, 0);
   timer = setInterval(fr, 500);
   time = new Date().getTime();
   animation = "animate";
   anim();
}
function anim(){
   draw();
   switch ( animation ){
     case "animate":
       setTimeout("requestAnimationFrame(anim)", delay); break;
     case "reset":
       main(); break;
   }
}
function draw(){
   gl.useProgram(prog);
   vaoExt.bindVertexArrayOES(computeVao);
   if (it > 0){ 
     gl.bindTexture(gl.TEXTURE_2D, texture);
     gl.bindFramebuffer(gl.FRAMEBUFFER, FBO2);}
   else{
     gl.bindTexture(gl.TEXTURE_2D, texture2);
     gl.bindFramebuffer(gl.FRAMEBUFFER, FBO);
   }
   gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
   gl.flush();
   gl.bindFramebuffer(gl.FRAMEBUFFER, null);
   var distort = false;
   if (distort) {
     gl.useProgram(prog_distort);
    vaoExt.bindVertexArrayOES(distortVao);
    gl.drawElements(gl.TRIANGLES, mesh.left.mesh.indices.length, 
       gl.UNSIGNED_SHORT, 0);
   } else {
     gl.useProgram(prog_show);
     gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
   }
   gl.flush();
   it = -it;  frames++;
}
function setDelay(v) {
  delay = parseInt(v);
}
function setDensity(v) {
  density = v.valueOf();
  animation = "reset";
}
function fr(){
  var ti = new Date().getTime();
  var fps = Math.round(1000*frames/(ti - time));
  document.getElementById("framerate").value = fps;
  frames = 0;  time = ti;
}
</script>

<style type="text/css">
  H1{ font-size: 120%; color: green}
</style>
</head>
<body onload="main()">
<table><tr><td>
<canvas id="c" width="512" height="512"></canvas>
<br><button onclick='animation="reset"'>Reset</button>
delay(ms)<input size="2" value="3" onchange="setDelay( this.value )">
density<input size="3" value="0.04" onchange="setDensity(this.value)">
fps<input size="2" id="framerate">
</td><td>
<h1>Conway's Game of Life on GPU</h1>

<br>One more 2D Life but only 7kb in one piece.
On HD 4850 I've got ~80 frames per sec.
<br>Random life-forms are funny but they freeze quickly :)
<br><a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Conway's
Game of Life (wiki)</a>
</td></tr></table>

<hr><a href="../webgl.htm">WebGL</a>
&nbsp; &nbsp; <i>updated</i> 25 Apr 2010
</body>
</html>

